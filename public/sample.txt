1. 色の定義とLab変換のヘルパー関数
まず、標準的な抵抗色と、Lab色空間への変換関数が必要です。特に金色は光の当たり方で大きく変わるため、複数のRGB表現を持つと有利です。

JavaScript

// 標準カラーコード定義の一部 (Goldとその周辺色)
const RESISTOR_COLORS = [
    // ... (他の色を省略)
    { name: 'Yellow', r: 255, g: 255, b: 0, value: 4 }, 
    { name: 'Gold', r: 218, g: 165, b: 32, value: -1, tolerance: 5 }, // 標準的なゴールド (#DAA520)
    { name: 'Gold_Light', r: 255, g: 215, b: 0, value: -1, tolerance: 5 }, // 明るい反射を持つゴールド (#FFD700)
    { name: 'Gold_Dark', r: 184, g: 134, b: 11, value: -1, tolerance: 5 }, // 影のあるゴールド (#B8860B)
    { name: 'Silver', r: 192, g: 192, b: 192, value: -2, tolerance: 10 },
    { name: 'Beige (Body)', r: 225, g: 204, b: 153 } // 抵抗器本体色
];

// RGBをLab色空間へ変換する関数 (前述の複雑なロジック)
function rgbToLab(r, g, b) {
    // ... RGB to XYZ to Lab 変換ロジックをここに実装 ...
    // この関数は、光沢や影による輝度の変化に強い色差計算を可能にします。
    const x = r / 255; // プレースホルダーとして簡略化
    const y = g / 255;
    const z = b / 255;
    return { l: 0, a: 0, b: 0 }; // 実際にはLab値
}

// CIE76 Delta E (色の知覚的距離) を計算する関数
function colorDistance(c1, c2) {
    const lab1 = rgbToLab(c1.r, c1.g, c1.b);
    const lab2 = rgbToLab(c2.r, c2.g, c2.b);
    return Math.sqrt(
        Math.pow(lab1.l - lab2.l, 2) +
        Math.pow(lab1.a - lab2.a, 2) +
        Math.pow(lab1.b - lab2.b, 2)
    );
}
2. 最も近い色を判定する関数（Goldの検出を含む）
Goldを正確に検出するためには、他の色（特にYellowやBrown）と誤認しないように、最も色差の小さい標準色を選択します。

JavaScript

/**
 * 与えられたピクセル色に最も近い標準の抵抗色を見つけます。
 * @param {object} pixel - 検出されたピクセルのRGB値 {r, g, b}
 * @returns {string} - 最も近い標準色名 (例: 'Gold', 'Brown', 'Red')
 */
function findClosestColor(pixel) {
    let minDist = Infinity;
    let closestName = null;

    for (const color of RESISTOR_COLORS) {
        const standardRgb = { r: color.r, g: color.g, b: color.b };
        const dist = colorDistance(pixel, standardRgb); // Lab色空間での距離計算

        // 許容差バンド（Gold, Silver）が検出される端の位置では、
        // 他のバンド色よりもGold/Silverを優先するバイアスをかけることも有効
        // 例: if (color.name === 'Gold' || color.name === 'Silver') { dist *= 0.9; }

        if (dist < minDist) {
            minDist = dist;
            closestName = color.name;
        }
    }
    
    // 検出された色がGoldのバリエーションであれば、統一して 'Gold' を返す
    if (closestName && closestName.startsWith('Gold')) {
        return 'Gold';
    }
    
    return closestName;
}

// ----------------------------------------------------
// 使用例 (画像処理からRGB値が抽出されたと仮定)
// ----------------------------------------------------
// 例 1: 強い反射で明るい金色になったピクセル
const pixel1 = { r: 250, g: 210, b: 10 }; 
// 期待される結果: 'Gold'
// const detectedColor1 = findClosestColor(pixel1); 

// 例 2: 本体色に近い影になった金色
const pixel2 = { r: 180, g: 150, b: 40 }; 
// 期待される結果: 'Gold'
// const detectedColor2 = findClosestColor(pixel2); 
3. Gold検出の精度を高める追加ロジック
上記のコードの精度をさらに高めるために、**画像解析の段階（ピクセル抽出時）**に以下のロジックを適用します。

多点サンプリングと多数決: Goldバンドの中心付近の複数のピクセルをサンプリングし、それぞれをfindClosestColorにかけます。最も多く検出された結果をそのバンドの色として採用することで、ノイズや単一ピクセルの誤認識を排除します。

位置によるバイアス: 抵抗器の右端にある色帯を検出する際、その色をGoldまたはSilverの標準色と比較する際に、他の色（例：Yellow）との距離に比べて判定のしきい値を緩く（または距離にバイアスをかけて優先）することで、許容差バンドの誤検出を防ぎます。